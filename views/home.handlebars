<header>
    {{{header}}}
</header>
<script src="/socket.io/socket.io.js"></script>
<main class="main">
    <table border="1">
        <tbody id="tbody1">
            <!-- таблица для доски -->
        </tbody>
    </table>
    <table border="1" style="opacity: 0.5;">
        <tbody id="tbody2">
            <!-- таблица для доски напарника-->
        </tbody>
    </table>
</main>

<script>



    class PlayField{
        constructor(){
            this.cells = [];             // поля игровой доски
            this.currentMove = 'white';  // кто сейчас ходит
            this.selectedChecker = null; // выбранная для хода шашка
        }

        endMove(){
            this.currentMove = this.currentMove == 'white' ? 'black' : 'white'; 
        }

        createGameField(numTable){
            const tbody = document.getElementById('tbody' + numTable);
            for(var i = 0; i < 8; i++){
                const row = document.createElement('tr');
                this.cells.push([]);
                for(var j = 0; j < 8; j++){
                    var color = (j + i) % 2  == 0 ? 'white' : 'black';
                    var td = document.createElement('td');
                    td.style.backgroundColor = color;

                    var checker = null;
                    if(color == 'black' && i != 3 && i != 4){
                        let shashka = document.createElement('div');

                        // checker init
                        var checkerColor = 'white'
                        if(i > 4) checkerColor = 'black'
                        checker = new Checker(shashka, checkerColor, j, i, this);

                        td.appendChild(shashka);
                    }
                    this.cells[i].push(new Cell(td, j, i, this, checker));
                    row.appendChild(td);
                }
                tbody.appendChild(row);
            }
        }

    }

    class Cell{
        constructor(tag, x, y, playField, checker = null){
            if (!this.inBounds(x, y)) throw new Error('invalid cell coordinates');
            this.x = x;
            this.y = y;
            this.tag = tag;
            this.pf = playField;
            this.checker = checker;

            this.tag.addEventListener('click', (e) => {
                if(this.pf.selectedChecker == null) return;
                if(this.pf.selectedChecker.x == this.x && this.pf.selectedChecker.y == this.y) return;

                console.log(`selected field - ${this.x};${this.y}`);
                
                this.pf.selectedChecker.removeHighLight();
                if (this.pf.selectedChecker.goTo(this)){
                    this.pf.selectedChecker = null;
                }
            });
        }

        setChecker(checker){
            this.tag.appendChild(checker.tag);
            this.checker = checker;
        }

        removeChecker(checker){
            this.tag.removeChild(checker.tag);
            this.checker = null;
        }

        inBounds(x, y){
            return x >= 0 && y >= 0 && x < 8 && y < 8;
        }
    }

    class Checker {
        constructor(tag, color, i, j, playField){
            tag.classList.add('checker');
            if (color == 'black')      tag.classList.add('checker-black');
            else if (color == 'white') tag.classList.add('checker-white');
            else throw new Error("invalid color");
            if (!this.inBounds(j, i)) throw new Error('invalid checker coordinates');
            this.color = color;
            this.tag = tag;
            this.x = i;
            this.y = j;
            this.pf = playField;
            this.isQueen = false;

            this.tag.addEventListener('click', (e) => {
                if(this.pf.selectedChecker != null) this.pf.selectedChecker.removeHighLight();
                this.pf.selectedChecker = this;
                console.log(`touched - ${this.x};${this.y}`);
                this.highLightMe();
            });
        }

        highLightMe(){
            this.tag.style.opacity = '0.5';
        }
        removeHighLight(){
            this.tag.style.opacity = '1';
        }


        // Лежит ли поле на одной диагонали с шашкой и черное ли оно
        checkFieldForMove(x, y){
            return Math.abs(x - this.x) === Math.abs(y - this.y) && (x + y) % 2 != 0;
        }

        inBounds(x, y){
            return x >= 0 && y >= 0 && x < 8 && y < 8;
        }

        goTo(cell){
            let x = cell.x;
            let y = cell.y;
            
            if(!this.checkFieldForMove(x, y) || !this.inBounds(x, y)) throw new Error('Not valid move');
            let distance = Math.abs(x - this.x);
            if (distance == 0) throw new Error('0 distance move');
            if (!this.isQueen && distance > 1) throw new Error('Too far move for not-a-queen checker');
            if (pf.cells[y][x].checker != null) throw new Error('Theres already another checker');
            if (pf.cells[this.y][this.x].checker == null) throw new Error('Current cell is empty');

            let oldCell = pf.cells[this.y][this.x];

            oldCell.removeChecker(this);
            cell.setChecker(this);

            this.x = x;
            this.y = y;
            return true;
        }
    }

    const pf = new PlayField();
    pf.createGameField(1);

    //createGameField(2);
    
</script>

<style>
    td{
        display: inline-flex;
        width: 26px;
        height: 26px;
        align-items: center;
        justify-content: center;
        position: relative;
    }

    .checker{
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: red;
    }

    .main{
        display: flex;
    }

    table{
        margin-left: 40px;
        margin-right: 40px;
    }

    .checker-white{
        background-color: bisque;
    }

    .checker-black{
        background-color: rgb(105, 98, 98);
    }


</style>
<script src="/socket.io/socket.io.js"></script>
<header>{{{ username }}}</header>
<main class="main">
    <table border="1">
        <tbody id="tbody1">
            <!-- таблица для доски -->
        </tbody>
    </table>
    <table border="1" style="opacity: 0.5;">
        <tbody id="tbody2">
            <!-- таблица для доски напарника-->
        </tbody>
    </table>
</main>

<script>

    class PlayField{
        constructor(){
            this.cells = [];                    // поля игровой доски
            this.currentMove = 'white';         // кто сейчас ходит
            this.selectedChecker = null;        // выбранная для хода шашка
            this.bottomCheckersColor = 'black'; // цвет шашек в нижней части, то есть каким цветом ходит игрок
        }

        endMove(){
            this.currentMove = this.currentMove == 'white' ? 'black' : 'white'; 
        }

        createGameField(numTable){
            const tbody = document.getElementById('tbody' + numTable);
            for(var i = 0; i < 8; i++){
                const row = document.createElement('tr');
                this.cells.push([]);
                for(var j = 0; j < 8; j++){
                    var color = (j + i) % 2  == 0 ? 'white' : 'black';
                    var td = document.createElement('td');
                    td.style.backgroundColor = color;

                    var checker = null;
                    if(color == 'black' && i != 3 && i != 4){
                        let shashka = document.createElement('div');

                        // checker init

                        var checkerColor = pf.bottomCheckersColor == 'black' ? 'white' : 'black';
                        if(i > 4) checkerColor = pf.bottomCheckersColor == 'black' ? 'black' : 'white';
                        checker = new Checker(shashka, checkerColor, j, i, this);

                        td.appendChild(shashka);
                    }
                    this.cells[i].push(new Cell(td, j, i, this, checker));
                    row.appendChild(td);
                }
                tbody.appendChild(row);
            }
        }

    }

    class Cell{
        constructor(tag, x, y, playField, checker = null){
            if (!this.inBounds(x, y)) throw new Error('invalid cell coordinates');
            this.x = x;
            this.y = y;
            this.tag = tag;
            this.pf = playField;
            this.checker = checker;

            this.tag.addEventListener('click', (e) => {
                if(this.pf.selectedChecker == null) return;
                if(this.pf.selectedChecker.x == this.x && this.pf.selectedChecker.y == this.y) return;

                console.log(`selected field - ${this.x};${this.y}`);
                
                this.pf.selectedChecker.removeHighLight();
                try{
                    this.pf.selectedChecker.goTo(this);
                }
                catch(e){
                    console.error(e.message);
                }
                finally{
                    this.pf.selectedChecker = null;
                }
            });
        }

        setChecker(checker){
            this.tag.appendChild(checker.tag);
            this.checker = checker;
        }

        removeChecker(){
            this.tag.removeChild(this.checker.tag);
            this.checker = null;
        }

        inBounds(x, y){
            return x >= 0 && y >= 0 && x < 8 && y < 8;
        }
    }

    class Checker {
        constructor(tag, color, i, j, playField){
            tag.classList.add('checker');
            if (color == 'black')      tag.classList.add('checker-black');
            else if (color == 'white') tag.classList.add('checker-white');
            else throw new Error("invalid color");
            if (!this.inBounds(j, i)) throw new Error('invalid checker coordinates');
            this.color = color;
            this.tag = tag;
            this.x = i;
            this.y = j;
            this.pf = playField;
            this.isQueen = false;

            this.tag.addEventListener('click', (e) => {
                if(this.pf.selectedChecker != null) this.pf.selectedChecker.removeHighLight();
                this.pf.selectedChecker = this;
                console.log(`touched - ${this.x};${this.y}`);
                this.highLightMe();
            });
        }

        highLightMe(){
            this.tag.style.opacity = '0.5';
        }
        removeHighLight(){
            this.tag.style.opacity = '1';
        }


        // Лежит ли поле на одной диагонали с шашкой и черное ли оно
        checkFieldForMove(x, y){
            return Math.abs(x - this.x) === Math.abs(y - this.y) && (x + y) % 2 != 0;
        }

        inBounds(x, y){
            return x >= 0 && y >= 0 && x < 8 && y < 8;
        }

        goTo(cell){
            let x = cell.x;
            let y = cell.y;
            
            if(!this.checkFieldForMove(x, y) || !this.inBounds(x, y)) throw new Error('Not valid move');
            if (pf.cells[y][x].checker != null) throw new Error('Theres already another checker');
            if (pf.cells[this.y][this.x].checker == null) throw new Error('Current cell is empty');

            let distance = this.y - y; // дистанция хода. Больше нуля - вверх, меньше - вниз
            if (distance == 0) throw new Error('0 distance move');
            if (!this.isQueen && distance > 2) throw new Error('Too far move for not-a-queen checker');
            if (
                (!this.isQueen && distance < 0 && this.color == pf.bottomCheckersColor) || 
                (!this.isQueen && distance > 0 && this.color != pf.bottomCheckersColor) // проверка на ход назад
            ) throw new Error('Cant go back if not a queen');

            let oldCell = pf.cells[this.y][this.x];
            if (Math.abs(distance) > 1){ // либо ходит дамка, либо кого то щас съедят, либо и то и то
                let xSign = (x - this.x) / Math.abs(x - this.x) // получаем знаки для координатных осей
                let ySign = (y - this.y) / Math.abs(y - this.y) 
                let eatenCell = null; // клетка с шашкой, которую планируется съесть
                for(let i = 1; i <= Math.abs(distance); i++){
                    // одна из клеток на диагонали поедания
                    let newX = this.x + i * xSign;
                    let newY = this.y + i * ySign;

                    let innerCell = pf.cells[newY][newX];
                    if (innerCell.checker == null) continue;
                    if (innerCell.checker.color == oldCell.checker.color) throw new Error('cant eat your checkers');
                    if (eatenCell != null) throw new Error('cant eat more then 1 checker at a time');
                    eatenCell = innerCell;
                }
                // если был ход на дистанцию 2, там не было что есть, а шашка не дамка
                if (eatenCell == null && !this.isQueen) throw new Error('too far move for not-a-queen checker');
                if(eatenCell){
                    eatenCell.removeChecker(); // съедена
                }
            }

            oldCell.removeChecker();
            cell.setChecker(this);

            this.x = x;
            this.y = y;
        }
    }

    const socket = io();

    const pf = new PlayField();
    pf.bottomCheckersColor = 'white';
    pf.createGameField(1);

    
</script>
